#!/usr/bin/env python3
"""
Post Exploitation Tools Category

This module provides automation for post-exploitation tools including:
- Privilege escalation
- Persistence mechanisms
- Lateral movement
- Data exfiltration
- Credential harvesting
- Keylogging and surveillance
- Backdoor management
"""

import asyncio
import json
import logging
import os
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PostExploitType(Enum):
    """Types of post-exploitation activities."""
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PERSISTENCE = "persistence"
    LATERAL_MOVEMENT = "lateral_movement"
    DATA_EXFILTRATION = "data_exfiltration"
    CREDENTIAL_HARVESTING = "credential_harvesting"
    SURVEILLANCE = "surveillance"
    BACKDOOR = "backdoor"


class EscalationMethod(Enum):
    """Methods of privilege escalation."""
    KERNEL_EXPLOIT = "kernel_exploit"
    SUID_BINARY = "suid_binary"
    SUDO_MISCONFIG = "sudo_misconfig"
    CRON_JOB = "cron_job"
    SERVICE_MISCONFIG = "service_misconfig"
    WEAK_PERMISSIONS = "weak_permissions"


@dataclass
class PostExploitResult:
    """Result of a post-exploitation activity."""
    activity_type: PostExploitType
    target: str
    success: bool
    details: dict[str, Any]
    timestamp: str
    duration: float
    output: str = None
    error: str = None


@dataclass
class SystemInfo:
    """Information about a target system."""
    hostname: str
    os_version: str
    kernel_version: str
    architecture: str
    current_user: str
    current_uid: int
    current_gid: int
    users: list[dict[str, Any]]
    groups: list[dict[str, Any]]
    processes: list[dict[str, Any]]
    network_interfaces: list[dict[str, Any]]
    open_ports: list[int]


class PostExploitationTools:
    """Main class for post-exploitation tool automation."""

    def __init__(self, config: dict[str, Any] = None):
        """Initialize post-exploitation tools."""
        self.config = config or {}
        self.output_dir = self.config.get('output_dir', '/tmp/post_exploit_output')
        self.artifacts_dir = os.path.join(self.output_dir, 'artifacts')
        self.reports_dir = os.path.join(self.output_dir, 'reports')

        # Create output directories
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(self.artifacts_dir, exist_ok=True)
        os.makedirs(self.reports_dir, exist_ok=True)

        # Tool paths
        self.tools = {
            'linpeas': 'linpeas.sh',
            'linenum': 'linenum.sh',
            'linux_exploit_suggester': 'linux-exploit-suggester.pl',
            'pspy': 'pspy',
            'pwncat': 'pwncat',
            'chisel': 'chisel',
            'ngrok': 'ngrok',
            'mimikatz': 'mimikatz.exe',
            'procdump': 'procdump.exe',
            'wget': 'wget',
            'curl': 'curl',
            'nc': 'nc',
            'socat': 'socat'
        }

        # Activity tracking
        self.activity_history: list[PostExploitResult] = []
        self.system_info_cache: dict[str, SystemInfo] = {}

        logger.info("Post exploitation tools initialized")

    async def gather_system_info(self, target: str = 'localhost') -> SystemInfo:
        """Gather comprehensive system information."""
        try:
            logger.info(f"Gathering system information from {target}")

            # Check if already cached
            if target in self.system_info_cache:
                return self.system_info_cache[target]

            # Basic system information
            hostname = await self._get_hostname()
            os_version = await self._get_os_version()
            kernel_version = await self._get_kernel_version()
            architecture = await self._get_architecture()

            # User information
            current_user = await self._get_current_user()
            current_uid = await self._get_current_uid()
            current_gid = await self._get_current_gid()

            # System details
            users = await self._get_users()
            groups = await self._get_groups()
            processes = await self._get_processes()
            network_interfaces = await self._get_network_interfaces()
            open_ports = await self._get_open_ports()

            system_info = SystemInfo(
                hostname=hostname,
                os_version=os_version,
                kernel_version=kernel_version,
                architecture=architecture,
                current_user=current_user,
                current_uid=current_uid,
                current_gid=current_gid,
                users=users,
                groups=groups,
                processes=processes,
                network_interfaces=network_interfaces,
                open_ports=open_ports
            )

            # Cache the result
            self.system_info_cache[target] = system_info

            logger.info(f"System information gathered for {target}")
            return system_info

        except Exception as e:
            logger.error(f"Error gathering system information: {e}")
            raise

    async def _get_hostname(self) -> str:
        """Get system hostname."""
        try:
            result = await self._run_command(['hostname'])
            if result['success']:
                return result['output'].strip()
            return 'Unknown'
        except Exception:
            return 'Unknown'

    async def _get_os_version(self) -> str:
        """Get operating system version."""
        try:
            # Try multiple methods
            commands = [
                ['cat', '/etc/os-release'],
                ['lsb_release', '-a'],
                ['uname', '-a']
            ]

            for cmd in commands:
                result = await self._run_command(cmd)
                if result['success']:
                    return result['output'].strip()

            return 'Unknown'
        except Exception:
            return 'Unknown'

    async def _get_kernel_version(self) -> str:
        """Get kernel version."""
        try:
            result = await self._run_command(['uname', '-r'])
            if result['success']:
                return result['output'].strip()
            return 'Unknown'
        except Exception:
            return 'Unknown'

    async def _get_architecture(self) -> str:
        """Get system architecture."""
        try:
            result = await self._run_command(['uname', '-m'])
            if result['success']:
                return result['output'].strip()
            return 'Unknown'
        except Exception:
            return 'Unknown'

    async def _get_current_user(self) -> str:
        """Get current user."""
        try:
            result = await self._run_command(['whoami'])
            if result['success']:
                return result['output'].strip()
            return 'Unknown'
        except Exception:
            return 'Unknown'

    async def _get_current_uid(self) -> int:
        """Get current user ID."""
        try:
            result = await self._run_command(['id', '-u'])
            if result['success']:
                return int(result['output'].strip())
            return 0
        except Exception:
            return 0

    async def _get_current_gid(self) -> int:
        """Get current group ID."""
        try:
            result = await self._run_command(['id', '-g'])
            if result['success']:
                return int(result['output'].strip())
            return 0
        except Exception:
            return 0

    async def _get_users(self) -> list[dict[str, Any]]:
        """Get system users."""
        try:
            users = []
            result = await self._run_command(['cat', '/etc/passwd'])

            if result['success']:
                lines = result['output'].split('\n')
                for line in lines:
                    if line.strip():
                        parts = line.split(':')
                        if len(parts) >= 7:
                            user_info = {
                                'username': parts[0],
                                'uid': int(parts[2]) if parts[2].isdigit() else 0,
                                'gid': int(parts[3]) if parts[3].isdigit() else 0,
                                'home': parts[5],
                                'shell': parts[6]
                            }
                            users.append(user_info)

            return users
        except Exception as e:
            logger.error(f"Error getting users: {e}")
            return []

    async def _get_groups(self) -> list[dict[str, Any]]:
        """Get system groups."""
        try:
            groups = []
            result = await self._run_command(['cat', '/etc/group'])

            if result['success']:
                lines = result['output'].split('\n')
                for line in lines:
                    if line.strip():
                        parts = line.split(':')
                        if len(parts) >= 4:
                            group_info = {
                                'groupname': parts[0],
                                'gid': int(parts[2]) if parts[2].isdigit() else 0,
                                'members': parts[3].split(',') if parts[3] else []
                            }
                            groups.append(group_info)

            return groups
        except Exception as e:
            logger.error(f"Error getting groups: {e}")
            return []

    async def _get_processes(self) -> list[dict[str, Any]]:
        """Get running processes."""
        try:
            processes = []
            result = await self._run_command(['ps', 'aux'])

            if result['success']:
                lines = result['output'].split('\n')
                for line in lines[1:]:  # Skip header
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 11:
                            process_info = {
                                'user': parts[0],
                                'pid': int(parts[1]) if parts[1].isdigit() else 0,
                                'cpu': float(parts[2]) if parts[2].replace('.', '').isdigit() else 0.0,
                                'mem': float(parts[3]) if parts[3].replace('.', '').isdigit() else 0.0,
                                'command': ' '.join(parts[10:])
                            }
                            processes.append(process_info)

            return processes[:100]  # Limit to first 100 processes
        except Exception as e:
            logger.error(f"Error getting processes: {e}")
            return []

    async def _get_network_interfaces(self) -> list[dict[str, Any]]:
        """Get network interface information."""
        try:
            interfaces = []
            result = await self._run_command(['ip', 'addr', 'show'])

            if result['success']:
                lines = result['output'].split('\n')
                current_interface = None

                for line in lines:
                    if line.strip():
                        if line[0].isdigit():
                            # New interface
                            parts = line.split(':')
                            if len(parts) >= 2:
                                current_interface = {
                                    'name': parts[1].strip(),
                                    'index': int(parts[0]),
                                    'state': 'UP' if 'UP' in line else 'DOWN',
                                    'addresses': []
                                }
                                interfaces.append(current_interface)
                        elif current_interface and 'inet ' in line:
                            # IP address
                            parts = line.split()
                            if len(parts) >= 2:
                                current_interface['addresses'].append(parts[1])

            return interfaces
        except Exception as e:
            logger.error(f"Error getting network interfaces: {e}")
            return []

    async def _get_open_ports(self) -> list[int]:
        """Get open ports."""
        try:
            ports = []
            result = await self._run_command(['netstat', '-tlnp'])

            if result['success']:
                lines = result['output'].split('\n')
                for line in lines[2:]:  # Skip header
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 4:
                            try:
                                addr_port = parts[3].split(':')
                                if len(addr_port) == 2:
                                    port = int(addr_port[1])
                                    ports.append(port)
                            except (ValueError, IndexError):
                                continue

            return list(set(ports))  # Remove duplicates
        except Exception as e:
            logger.error(f"Error getting open ports: {e}")
            return []

    async def check_privilege_escalation(self, target: str = 'localhost') -> PostExploitResult:
        """Check for privilege escalation opportunities."""
        try:
            logger.info(f"Checking privilege escalation opportunities on {target}")
            start_time = time.time()

            system_info = await self.gather_system_info(target)
            findings = []

            # Check if already root
            if system_info.current_uid == 0:
                findings.append({
                    'type': 'already_root',
                    'description': 'Already running as root user',
                    'severity': 'info'
                })
            else:
                # Check SUID binaries
                suid_findings = await self._check_suid_binaries()
                findings.extend(suid_findings)

                # Check sudo configuration
                sudo_findings = await self._check_sudo_config()
                findings.extend(sudo_findings)

                # Check cron jobs
                cron_findings = await self._check_cron_jobs()
                findings.extend(cron_findings)

                # Check service misconfigurations
                service_findings = await self._check_service_misconfigs()
                findings.extend(service_findings)

                # Check weak file permissions
                permission_findings = await self._check_weak_permissions()
                findings.extend(permission_findings)

            duration = time.time() - start_time

            result = PostExploitResult(
                activity_type=PostExploitType.PRIVILEGE_ESCALATION,
                target=target,
                success=True,
                details={
                    'findings': findings,
                    'current_user': system_info.current_user,
                    'current_uid': system_info.current_uid
                },
                timestamp=time.strftime('%Y-%m-%d %H:%M:%S'),
                duration=duration,
                output=json.dumps(findings, indent=2)
            )

            self.activity_history.append(result)
            return result

        except Exception as e:
            logger.error(f"Error checking privilege escalation: {e}")
            return PostExploitResult(
                activity_type=PostExploitType.PRIVILEGE_ESCALATION,
                target=target,
                success=False,
                details={'error': str(e)},
                timestamp=time.strftime('%Y-%m-%d %H:%M:%S'),
                duration=0,
                error=str(e)
            )

    async def _check_suid_binaries(self) -> list[dict[str, Any]]:
        """Check for SUID binaries."""
        findings = []

        try:
            result = await self._run_command(['find', '/usr/bin', '/usr/sbin', '/bin', '/sbin', '-perm', '-4000', '-type', 'f'])

            if result['success']:
                suid_binaries = result['output'].strip().split('\n')

                for binary in suid_binaries:
                    if binary.strip():
                        # Check if it's a known dangerous SUID binary
                        dangerous_suid = [
                            'nmap', 'vim', 'nano', 'less', 'more', 'cat',
                            'bash', 'sh', 'python', 'perl', 'ruby'
                        ]

                        binary_name = os.path.basename(binary)
                        if binary_name in dangerous_suid:
                            findings.append({
                                'type': 'dangerous_suid',
                                'description': f'Dangerous SUID binary: {binary}',
                                'binary': binary,
                                'severity': 'high'
                            })
                        else:
                            findings.append({
                                'type': 'suid_binary',
                                'description': f'SUID binary found: {binary}',
                                'binary': binary,
                                'severity': 'medium'
                            })

        except Exception as e:
            logger.error(f"Error checking SUID binaries: {e}")

        return findings

    async def _check_sudo_config(self) -> list[dict[str, Any]]:
        """Check sudo configuration for misconfigurations."""
        findings = []

        try:
            # Check if user can run sudo
            result = await self._run_command(['sudo', '-l'])

            if result['success']:
                output = result['output']

                # Check for NOPASSWD
                if 'NOPASSWD' in output:
                    findings.append({
                        'type': 'sudo_nopasswd',
                        'description': 'User can run sudo without password',
                        'severity': 'high'
                    })

                # Check for specific command permissions
                if 'ALL' in output:
                    findings.append({
                        'type': 'sudo_all',
                        'description': 'User can run all commands with sudo',
                        'severity': 'high'
                    })

                # Check for specific dangerous commands
                dangerous_commands = ['cat', 'vim', 'nano', 'less', 'more', 'bash', 'sh']
                for cmd in dangerous_commands:
                    if cmd in output:
                        findings.append({
                            'type': 'sudo_dangerous_command',
                            'description': f'User can run {cmd} with sudo',
                            'command': cmd,
                            'severity': 'medium'
                        })

        except Exception as e:
            logger.error(f"Error checking sudo config: {e}")

        return findings

    async def _check_cron_jobs(self) -> list[dict[str, Any]]:
        """Check cron jobs for privilege escalation opportunities."""
        findings = []

        try:
            # Check system cron jobs
            cron_dirs = ['/etc/cron.d', '/etc/cron.daily', '/etc/cron.hourly', '/etc/cron.monthly', '/etc/cron.weekly']

            for cron_dir in cron_dirs:
                if os.path.exists(cron_dir):
                    result = await self._run_command(['ls', '-la', cron_dir])
                    if result['success']:
                        lines = result['output'].split('\n')
                        for line in lines:
                            if line.strip() and not line.startswith('total'):
                                parts = line.split()
                                if len(parts) >= 9:
                                    filename = parts[-1]
                                    permissions = parts[0]

                                    # Check if writable by current user
                                    if 'w' in permissions[7:10]:  # Group write
                                        findings.append({
                                            'type': 'writable_cron',
                                            'description': f'Writable cron file: {os.path.join(cron_dir, filename)}',
                                            'file': os.path.join(cron_dir, filename),
                                            'permissions': permissions,
                                            'severity': 'high'
                                        })

            # Check user crontab
            result = await self._run_command(['crontab', '-l'])
            if result['success'] and result['output'].strip():
                findings.append({
                    'type': 'user_crontab',
                    'description': 'User has crontab entries',
                    'entries': result['output'].strip(),
                    'severity': 'info'
                })

        except Exception as e:
            logger.error(f"Error checking cron jobs: {e}")

        return findings

    async def _check_service_misconfigs(self) -> list[dict[str, Any]]:
        """Check for service misconfigurations."""
        findings = []

        try:
            # Check for writable service files
            service_dirs = ['/etc/systemd/system', '/etc/init.d', '/etc/rc.d']

            for service_dir in service_dirs:
                if os.path.exists(service_dir):
                    result = await self._run_command(['find', service_dir, '-type', 'f', '-writable'])
                    if result['success'] and result['output'].strip():
                        writable_services = result['output'].strip().split('\n')
                        for service in writable_services:
                            if service.strip():
                                findings.append({
                                    'type': 'writable_service',
                                    'description': f'Writable service file: {service}',
                                    'file': service,
                                    'severity': 'high'
                                })

        except Exception as e:
            logger.error(f"Error checking service misconfigs: {e}")

        return findings

    async def _check_weak_permissions(self) -> list[dict[str, Any]]:
        """Check for weak file permissions."""
        findings = []

        try:
            # Check for world-writable files in important directories
            important_dirs = ['/etc', '/var', '/usr', '/opt']

            for directory in important_dirs:
                if os.path.exists(directory):
                    result = await self._run_command(['find', directory, '-type', 'f', '-perm', '-002', '-ls'])
                    if result['success'] and result['output'].strip():
                        lines = result['output'].strip().split('\n')
                        for line in lines[:50]:  # Limit results
                            if line.strip():
                                parts = line.split()
                                if len(parts) >= 10:
                                    permissions = parts[2]
                                    file_path = parts[-1]

                                    # Check if it's a sensitive file
                                    sensitive_patterns = ['passwd', 'shadow', 'sudoers', 'ssh', 'config']
                                    if any(pattern in file_path for pattern in sensitive_patterns):
                                        findings.append({
                                            'type': 'world_writable_sensitive',
                                            'description': f'World-writable sensitive file: {file_path}',
                                            'file': file_path,
                                            'permissions': permissions,
                                            'severity': 'critical'
                                        })
                                    else:
                                        findings.append({
                                            'type': 'world_writable',
                                            'description': f'World-writable file: {file_path}',
                                            'file': file_path,
                                            'permissions': permissions,
                                            'severity': 'medium'
                                        })

        except Exception as e:
            logger.error(f"Error checking weak permissions: {e}")

        return findings

    async def _run_command(self, cmd: list[str]) -> dict[str, Any]:
        """Run a command and return results."""
        try:
            logger.debug(f"Running command: {' '.join(cmd)}")

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            return {
                'success': process.returncode == 0,
                'output': stdout.decode('utf-8', errors='ignore'),
                'error': stderr.decode('utf-8', errors='ignore'),
                'return_code': process.returncode
            }

        except Exception as e:
            logger.error(f"Error running command {' '.join(cmd)}: {e}")
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'return_code': -1
            }

    def get_activity_history(self) -> list[PostExploitResult]:
        """Get activity history."""
        return self.activity_history

    def get_system_info_cache(self) -> dict[str, SystemInfo]:
        """Get cached system information."""
        return self.system_info_cache

    def cleanup(self):
        """Clean up resources."""
        try:
            logger.info("Post exploitation tools cleanup completed")
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")


# Example usage and testing
async def main():
    """Example usage of post exploitation tools."""
    tools = PostExploitationTools()

    try:
        # Gather system information
        print("Gathering system information...")
        system_info = await tools.gather_system_info()
        print(f"Hostname: {system_info.hostname}")
        print(f"Current user: {system_info.current_user} (UID: {system_info.current_uid})")

        # Check privilege escalation opportunities
        print("Checking privilege escalation opportunities...")
        escalation_result = await tools.check_privilege_escalation()
        print(f"Privilege escalation check completed: {len(escalation_result.details['findings'])} findings")

    finally:
        tools.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
